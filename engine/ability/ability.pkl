abstract module ability
extends "../data.pkl"
import "../types.pkl" as $t

fixed type: String = "ability"

activation_type: "auto" | "activated" | "passive" = 
  if (primary) "auto" 
  else "activated"

ability_type: "attack" | "heal" | "spell" | "switch-attack" | "toggle-siege" | "talent" | "topbar-power" = if (primary) "attack" else null

fixed subtype: String = 
  let (l = List(ability_type, activation_type)) 
  l.join("/")

hotkey: $t.HotKey?
targets: Listing<$t.TargetType>
requires_mode: String?
toggles_mode: String?
energy_cost: UInt?
energy_type: $t.EnergyType?
/// also called reload_time
cooldown: Number?
cooldown_at_build: Boolean = true
duration: Float?
range: UInt?
/// also called damage point, attack delay, or cast point
delay: Float?
ability_of: String?

num_casts: UInt?
shots_per_cast: UInt?

local function x_per_sec(val: UInt?, num: UInt?, shots: UInt?, cd: Number?) =
  if (val == null) null else 
  if (cd == null) null else
  let (v = val.toFloat())
  let (n = (num ?? 1).toFloat())
  let (s = (shots ?? 1).toFloat())
  ((v * n * s) / cd).round().toInt()

damage: UInt?
damage_per_sec: UInt? = x_per_sec(damage, num_casts, shots_per_cast, cooldown)
healing: UInt?
healing_per_sec: UInt? = x_per_sec(healing, num_casts, shots_per_cast, cooldown)

area: UInt?
dot_damage: UInt?
dot_time: Float?
splash_amount: UInt?
splash_radius: UInt?
bonus_percent: UInt?
bonus_vs_tags: Listing<String>?
autocast: "always" | "toggle" | "never" = if (activation_type == "auto") "always" else "never"
