/// root object of this engine. basic data type for all game objects & effects.
abstract module data
import "pkl:reflect"
import "types.pkl" as $t
import "path_data.pkl" as $p
import "data.pkl" as me


local meref = reflect.moduleOf(this)

hidden path_parts: List<String> = meref.uri
  .replaceAll(Regex(#"^.*(factions|maps|engine)/"#), "$1/")
  .split("/")

hidden src_dir_parts: List<String> = path_parts.dropLast(1)
hidden src_dir_slugs: List<String> = src_dir_parts.map((x) -> x.replaceAll("_", "-"))
hidden fixed src_dir: String = src_dir_parts.join("/")
hidden fixed src_file: String = path_parts.takeLast(1).first
fixed src: String = List(src_dir, src_file).join("/")
fixed slug: $t.Slug = src_file.replaceLast(".pkl", "").replaceAll("_", "-")
fixed id: $t.Id = (src_dir_slugs + List(slug)).join("/")

/// metadata pulled from path. this includes things used in multiple subclasses
from_path: $p.PathData = $p.dataFromPath(src_dir_parts)

/// nicely formatted display name, as it appears in game (with the exception of things without lore names yet)
name: String 

/// in-game description of this
description: String?

/// top-level type. overridden to a specific one of these by a subclass
fixed type: String = from_path.type

/// sub-type. data subclasses will define this as a calculated field, based on a more
fixed subtype: String = from_path.subtype

/// faction name. required if type isn't map. should not be defined for faction type
fixed faction: String? = from_path.faction

/// tags used in calculating effects of parts of the game, such as `unit` or `vehicle` or `massive`. these should be static tags based on type.
hidden add_tags: Listing<String>

/// this one is for subclasses, so they dont have to do the distinct filtering below themselves. these are dynamic tags based on other properties.
hidden fixed extend_tags: Listing<String> 

/// some tags are auto-generated, this is where auto-generation happens
fixed tags: Listing<String>(isDistinct) = (new Listing<String> {
  ...from_path.tags
  ...add_tags
  ...extend_tags
  type 
  "\(type):\(subtype)"
  when (faction != null) { "faction:\(faction)" }
}.toList().distinct.toListing())

/// whether or not this exists in the game at the current version
in_game: Boolean = true

/// additional notes and information about this gamepiece
notes: Listing<String>

/// creates handles things that build / produce / cast / otherwise create. should always be paired with created_by on the other side.
creates: Listing<$t.Slug>(isDistinct)?

/// opposite side of creates, this should always be paired with unlocks on the other side
created_by: Listing<$t.Slug>(isDistinct)?

/// unlocks handles things that allow other things the ability to build / produce / cast / otherwise create. should always be paired with unlocked_by on the other side.
unlocks: Listing<$t.Slug>(isDistinct)?

/// opposite side of unlocks, this should always be paired with unlocks on the other side
unlocked_by: Listing<$t.Slug>(isDistinct)?

/// currently only buildings do this, but its here because the other unlock/create logic is here. some non-gamepieces gamepieces unlock/create 
unlocks_merc_tier: Listing<$t.Tier>(isDistinct)?

/// not rendered, but used to generate final flat output
hidden fixed children: List<me> = List()

/// not rendered, but used to generate final flat output
hidden fixed recursive_children: List<me> = List()

