/// root object of this engine. basic data type for all game objects & effects.
abstract module data
import "pkl:reflect"
import "types.pkl" as $t
import "path_inspection.pkl" as $p
import "data.pkl" as me
import "versioning.pkl"

local methis = this
local meref = reflect.moduleOf(this)
local isimpl = !meref.uri.matches(Regex("/engine/"))

hidden path_parts: List<String> = meref.uri
  .replaceAll(Regex(#"^.*/(faction|mercenary|nonplayer|maps|engine)/"#), "$1/")
  .split("/")

hidden src_dir_parts: List<String> = path_parts.dropLast(1)
hidden src_dir_slugs: List<String> = src_dir_parts.map((x) -> x.replaceAll("_", "-"))
hidden fixed src_dir: String = src_dir_parts.join("/")
hidden fixed src_file: String = path_parts.takeLast(1).first
fixed src: String = List(src_dir, src_file).join("/")
fixed slug: $t.Slug = src_file.replaceLast(".pkl", "").replaceAll("_", "-")
fixed id: $t.Id = (src_dir_slugs + List(slug)).join("/")

/// metadata pulled from path. this includes things used in multiple subclasses
hidden fixed fromPath: $p.PathData = $p.dataFromPath(src_dir_parts)

zsVersion: String = versioning.zsVersion
zsggDataVersion: String = versioning.zsggDataVersion
zsggDataUpdated: String = versioning.zsggDataUpdated
release: String = versioning.release

// fullId: String = "\(id)@\(release)"

/// nicely formatted display name, as it appears in game (with the exception of things without lore names yet)
name: String 

shortName: String = name

/// in-game description of this
description: String? = "[in-game/informational description missing]"

/// top-level type. overridden to a specific one of these by a subclass
fixed type: String = fromPath.type

/// sub-type. data subclasses will define this as a calculated field, based on a more
fixed subtype: String = fromPath.subtype

/// faction name. required if type isn't map. should not be defined for faction type
fixed faction: String? = fromPath.faction

flavor: String? = "[Submit flavor @ zsgg discord]"

// flavorDescription: String? = "[Missing a zsgg-style fun description of this. You can submit your idea on the zsgg discord!]"

role: String? = "[Submit role @ zsgg discord]"

tier: $t.Tier? = fromPath.tier

/// tags used in calculating effects of parts of the game, such as `unit` or `vehicle` or `massive`. these should be static tags based on type.
tags: Listing<String>

/// Used to add tags that are dependent on other fields
fixed tag_list: Listing<String> = new {
  ...tags
  ...fromPath.tags
  type 
  "\(type):\(subtype)"
  when (faction != null) { "faction:\(faction)" }
}

/// whether or not this exists in the game at the current version
inGame: Boolean = true

fromFuture: Boolean = false

/// additional notes and information about this gamepiece
notes: Listing<String>

/// creates handles things that build / produce / cast / otherwise create. should always be paired with createdBy on the other side.
creates: Listing<$t.Slug>(isDistinct)?

/// opposite side of creates, this should always be paired with unlocks on the other side
createdBy: Listing<$t.Slug>(isDistinct)?

/// unlocks handles things that allow other things the ability to build / produce / cast / otherwise create. should always be paired with unlockedBy on the other side.
unlocks: Listing<$t.Slug>(isDistinct)?

/// opposite side of unlocks, this should always be paired with unlocks on the other side
unlockedBy: Listing<$t.Slug>(isDistinct)?

/// currently only buildings do this, but its here because the other unlock/create logic is here. some non-gamepieces gamepieces unlock/create 
unlocksMercTier: Listing<$t.Tier>(isDistinct)?

hidden fixed children: List<me> = List()
hidden fixed recursive_children: List<me> = children + children.flatMap((c) -> c.recursive_children)

hidden fixed rendered_files: Listing<String> = new Listing<String> {
  "\(id).json"
  when (recursive_children.length > 0) { "\(id)-nested.json" }
  for (child in recursive_children) { "\(child.id).json" }
}

hidden output {
  files {
    ["\(id).json"] {
      renderer = new JsonRenderer { indent = "" }
      value = methis
    }
    when (recursive_children.length > 0) {
      ["\(id)-nested.json"] {
        renderer = new JsonRenderer { indent = "" }
        value = methis
      }
    }
    for (child in recursive_children) {
      ["\(child.id).json"] {
        renderer = new JsonRenderer { indent = "" }
        value = child
      }
    }
  }
}

