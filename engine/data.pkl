/// root object of this engine. basic data type for all game objects & effects.
abstract module data
import "pkl:reflect"
import "types.pkl" as $t
import "path_inspection.pkl" as $p
import "data.pkl" as me
import "versioning.pkl"

local methis = this
local meref = reflect.moduleOf(this)
local isimpl = !meref.uri.matches(Regex("/engine/"))

hidden path_parts: List<String> = meref.uri
  .replaceAll(Regex(#"^.*/(faction|mercenary|nonplayer|maps|engine)/"#), "$1/")
  .split("/")

hidden src_dir_parts: List<String> = path_parts.dropLast(1)
hidden src_dir_slugs: List<String> = src_dir_parts.map((x) -> x.replaceAll("_", "-"))
hidden fixed src_dir: String = src_dir_parts.join("/")
hidden fixed src_file: String = path_parts.takeLast(1).first
fixed src: String = List(src_dir, src_file).join("/")
fixed slug: $t.Slug = src_file.replaceLast(".pkl", "").replaceAll("_", "-")
fixed id: $t.Id = (src_dir_slugs + List(slug)).join("/")

hidden repoSlug = "zerospace-gg/zsgg-librarian";

/// metadata pulled from path. this includes things used in multiple subclasses
hidden fixed fromPath: $p.PathData = $p.dataFromPath(src_dir_parts)

zsVersion: String = versioning.zsVersion
ggVersion: String = versioning.ggVersion
ggUpdated: String = versioning.ggUpdated
ggRelease: String = versioning.ggRelease

ggUrl = "https://zerospace.gg/library/\(id)/";
githubUrl = "https://github.com/\(repoSlug)/blob/main/zerospace/\(src)";
githubRawUrl = "https://raw.githubusercontent.com/\(repoSlug)/main/zerospace/\(src)";

/// nicely formatted display name, as it appears in game (with the exception of things without lore names yet)
name: String 

shortName: String = name

/// in-game description of this
description: String? 

/// top-level type. overridden to a specific one of these by a subclass
fixed type: String = fromPath.type

/// sub-type. data subclasses will define this as a calculated field, based on a more
fixed subtype: String = fromPath.subtype

/// faction name. required if type isn't map. should not be defined for faction type
fixed faction: String? = fromPath.faction

tier: $t.Tier? = fromPath.tier

/// tags used in calculating effects of parts of the game, such as `unit` or `vehicle` or `massive`. these should be static tags based on type.
hidden tags: Listing<String>

hidden fixed dynamicTags: Listing<String> = new {
  type 
  "\(type):\(subtype)"
  when (faction != null) { "faction:\(faction)" }
}

/// Used to add tags that are dependent on other fields
fixed tagList: Listing<String> = new Listing<String> {
  ...tags
  ...dynamicTags
  ...fromPath.tags
}.toList().distinct.toListing()
/// whether or not this exists in the game at the current version
inGame: Boolean = true

fromFuture: Boolean = false

/// additional notes and information about this gamepiece
notes: Listing<String>

/// creates handles things that build / produce / cast / otherwise create. should always be paired with createdBy on the other side.
creates: Listing<$t.Slug>(isDistinct)?

/// opposite side of creates, this should always be paired with unlocks on the other side
createdBy: Listing<$t.Slug>(isDistinct)?

/// unlocks handles things that allow other things the ability to build / produce / cast / otherwise create. should always be paired with unlockedBy on the other side.
unlocks: Listing<$t.Slug>(isDistinct)?

/// opposite side of unlocks, this should always be paired with unlocks on the other side
unlockedBy: Listing<$t.Slug>(isDistinct)?

/// currently only buildings do this, but its here because the other unlock/create logic is here. some non-gamepieces gamepieces unlock/create 
unlocksMercTier: Listing<$t.Tier>(isDistinct)?

references: Listing<$t.Slug>(isDistinct)? = new Listing<$t.Slug> {
  ...(creates ?? new Listing{})
  ...(createdBy ?? new Listing{})
  ...(unlocks ?? new Listing{})
  ...(unlockedBy ?? new Listing{})
  ...recursive_children.map((c) -> c.slug)
}.toList().distinct.toListing()

hidden fixed children: List<me> = List()
hidden fixed recursive_children: List<me> = children + children.flatMap((c) -> c.recursive_children)

hidden fixed rendered_files: Listing<String> = new Listing<String> {
  "\(id).json"
  when (recursive_children.length > 0) { "\(id)-nested.json" }
  for (child in recursive_children) { "\(child.id).json" }
}

hidden output {
  files {
    ["\(id).json"] {
      renderer = new JsonRenderer { indent = "" }
      value = methis
    }
    for (child in recursive_children) {
      ["\(child.id).json"] {
        renderer = new JsonRenderer { indent = "" }
        value = child
      }
    }
  }
}

