/// gamepiece is the superclass for units, buildings, etc, and represents an on-screen, in-game object. 
abstract module gamepiece 
extends "data.pkl"
import "data.pkl"
import "turret.pkl" as Turret
import "parent_info.pkl" as ParentInfo
import "ability.pkl" as Ability
import "types.pkl" as $t
import "gamepiece.pkl" as me
local methis = this

hidden fixed extend_tags = (super.extend_tags) {
  when (armorType != "none") { "armor:\(armorType)" }
  when ((gathersRichFlux ?? 0) > 0) { "gathers:flux" }
  when ((gathersFlux ?? 0) > 0) { "gathers:flux" }
  when ((gathersHexite ?? 0) > 0) { "gathers:hexite" }
  when ((gathersEmptyHexite ?? 0) > 0) { "gathers:hexite" }
  when (domain == "air") { "flyer" }
  when ((armor ?? 0) > 0) { "armored" }
  when ((provedsSupply ?? 0) > 0) { "supply" }
  when ((providesBiomass ?? 0) > 0) { "biomass" }
  when ((providesDetection ?? 0) > 0) { "detection" }
  when ((providesUpgradesFor?.length ?? 0) > 0) { "upgrades" }
  when ((upgradedBy?.length ?? 0) > 0) { "upgradable" }
  when ((shields ?? 0) > 0) { "shielded" }
  when ((abesEnergy ?? 0) > 0) { "abes" }
  when ((energy ?? 0) > 0) { "energy" }
  when ((stunResist ?? 0) > 0) { "resist:stun" }
  when ((maxTurrets ?? 0) > 0 && hasTurretType == "turret") { "has:turrets" }
  when (hasTurretType == "sacrifice") { "sacrifices" }
}

/// short description of the purpose of this, to be used in summaries in UI. Many of these won't be in game. 
/// examples: "fast melee attacker" for a unit, "vision buff" for an upgrade, etc
flavor: String?

/// hexite cost to build. 0 for gamepieces that are cast
hexiteCost: Number? 
fluxCost: Number?
buildCount: Number? = 1
cooldown: Number?
energyCost: Number?
energyCostType: $t.EnergyType? 
buildTime: Number?
rebuildable: Boolean?
rebuildTime: Number?
domain: $t.DomainType = "ground"

hotkey: $t.HotKey?

gathersFlux: Number? = fromPath.gathersFlux
gathersRichFlux: Number? = fromPath.gathersRichFlux

gathersHexite: Number? = fromPath.gathersHexite
gathersEmptyHexite: Number? = fromPath.gathersEmptyHexite

supply: Number? = fromPath.supply
hp: Number? = fromPath.hp
vision: Number? = fromPath.vision
speed: Number? = fromPath.speed
shields: Number? 
abesEnergy: Number? 
energy: Number?
armor: Number? = fromPath.armor

armorType: $t.ArmorType = fromPath.armorType ?? "none" 
stunResist: Number? 

provedsSupply: Number? = fromPath.provedsSupply
providesBiomass: Number? = fromPath.providesBiomass
providesDetection: Number?
providesUpgradesFor: Listing<String>(isDistinct)?

upgradedBy: Listing<String>(isDistinct)?

transformsFrom: Listing<String>(isDistinct)?
transformsInto: Listing<String>(isDistinct)?

maxTurrets: Number?
hasTurretType: "turret" | "sacrifice"? =
  if (turrets.length == 0) null 
  else throw("hasTurretType must be set if turrets is used.")

local parent_info: ParentInfo = new {
  id = methis.id
  slug = methis.slug
  src = methis.src
  fromPath = methis.fromPath
}

hidden attacks: Mapping<String, Ability> = new Mapping<String, Ability> {
  default { key -> name = key; parent = parent_info; abilityType = "attack" }
}
attack: Mapping<String, Ability> = new {
  for (_attack in attacks) {
    [_attack.slug] = _attack
  }
}

hidden heals: Mapping<String, Ability> = new Mapping<String, Ability> {
  default { key -> name = key; parent = parent_info; abilityType = "heal" }
}
heal: Mapping<String, Ability> = new {
  for (_heal in heals) {
    [_heal.slug] = _heal
  }
}

hidden spells: Mapping<String, Ability> = new Mapping<String, Ability> {
  default { key -> name = key; parent = parent_info; abilityType = "spell" }
}
spell: Mapping<String, Ability> = new {
  for (_spell in spells) {
    [_spell.slug] = _spell
  }
}

hidden passives: Mapping<String, Ability> = new Mapping<String, Ability> {
  default { key -> name = key; parent = parent_info; abilityType = "passive" }
}
passive: Mapping<String, Ability> = new {
  for (_passive in passives) {
    [_passive.slug] = _passive
  }
}

hidden turrets: Mapping<String, Turret> = new Mapping<String, Turret> {
  default { key -> name = key; parent = parent_info; turretType = methis.hasTurretType }
}
turret: Mapping<String, Turret> = new {
  for (_turret in turrets) {
    [_turret.slug] = _turret
  }
}

hidden fixed children = List(attacks, heals, spells, passives, turrets).flatMap((x) -> x.toMap().values.toList())

